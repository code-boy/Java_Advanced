# Java代理和动态代理机制分析和应用 #  
###概述  
代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。

####代理模式一般涉及到的角色有4种  
1. 主题接口：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；
1. 真实主题：真正实现业务逻辑的类；
1. 代理类：用来代理和封装真实主题；
1. 客户端：使用代理类和主题接口完成一些工作。   
  
![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/400px-Proxy_pattern_diagram.svg.png)  
在代理模式中真实主题角色对于客户端角色来说的透明的，也就是客户端不知道也无需知道真实主题的存在。
为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。  
#####代理模式的应用场景  
代理的使用场景很多，struts2中的 action 调用， hibernate的懒加载， spring的 AOP无一不用到代理。总结起来可分为以下几类：
1. 在原方法执行之前和之后做一些操作，可以用代理来实现（比如记录Log）。
2. 封装真实的主题类，将真实的业务逻辑隐藏，只暴露给调用者公共的主题接口。
3. 在延迟加载上的应用。  

###静态代理  
所谓静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 
下面有个场景，一个房主要出售自己的房子，但房主不知道谁要买房，也没有时间去接待每一个看房者。  
现在我们就用静态代理的方式来实现房主的这一需求。  
**首先，将出售房屋抽象成公共代理接口(Sales)** 
```java
/**
 * 主题接口：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法。<br>
 * 在这里表示销售
 * @author Penn
 */
public interface Sales {
	void sell();
}
```  
Salese接口里面提供了sell方法表示出售房屋。  
**其次，房主做为整个事件的主角，自然而然的就成了真实主题，也是代理的委托者**  
```java 
/**
 * 真实主题，具体处理业务。<br>
 * 在这里表示房东
 * @author Penn
 */
public class Owner implements Sales{
	@Override
	public void sell() {
		System.out.println("我是房东我正在出售我的房产");
	}
}
```  
真实主题Owner实现了Sales接口，在接口提供的sell()方法里出售自己的房屋。
 
**再次，给房主找个中介(Agents)，作为房主出售房屋的代理**
```java
/**
 * 代理类：用来代理和封装真实主题<br>
 * 在这里表示房产中介
 * @author Penn
 */
public class Agents implements Sales {
	private Owner owner;
	public Agents() {
	}
	@Override
	public void sell() {
		System.out.println("我是房产中介，正在核实买房者是否符合购买该房屋的资格");
		getOwner().sell();
		System.out.println("我是房产中介，正在收取提成");
	}
	private Owner getOwner() {
		if (owner==null) {
			owner=new Owner();
		}
		return owner;
	}
}

```  
为了帮房主出售房屋，Agents代理也实现了Sales接口。同时Agents也拥有Owner的成员对象，在实现的sell()接口方法里，代理Agents帮房主Owner预处理了一些消息，然后调用了owner对象的sell()方法通知房主出售房屋，在房主Owner出售完房屋后，代理Agents开始收取中介费。有心的读者可以发现，代理Agents在访问Owner对象的时候使用了getOwner()方法，从而达到了在客户真正决定买房的时候才初始化owner对象，而不是在Agents初始化的时候就将Owner初始化。真实情境中，会有很多购房者要看房，但真正买的人只有一个，所以在代理Agents帮房东预处理和过滤掉所有信息之后，告诉房东你可以出售房屋了，这样大大节省了房东的时间和简化了售房的繁琐过程。而这也是用代理来实现延迟加载的好处。
**最后，万事俱备只欠买房的顾客了（Customer）**  
```java 
/**
 * 客户端，使用代理类和主题接口完成一些工作。<br>
 * 在这里表示买房子的客户
 * @author Penn
 */
public class Customer {
	public static void main(String[]args) {
		Sales sales=new Agents();
		sales.sell();
	}
}
```  
在这里买房的顾客Customer找到房产代理Agents，告诉他要买房。整个过程房东Owner对顾客Customer来说是透明的，Customer只与Agents打交道，Owner也只与Agents打交道，Agents作为Owner和Customer通信的桥梁从而有效控制了Customer和Owner的直接交流。  
####静态代理类优缺点  
优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。  
缺点：  
1）代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。    
2）如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。   
另外，如果要按照上述的方法使用代理模式，那么真实角色(委托类)必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色（委托类），该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。  
###动态代理